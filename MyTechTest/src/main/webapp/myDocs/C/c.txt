在10.25.23.102上测试：
文件放在：/root/c下面
编译：g++ helloCpp.cpp -o helloCpp
运行：./helloCpp

新版C++也对头文件的命名做了调整，去掉了后缀.h，所以老式C++的 <iostream.h> 变成了 <iostream>，
<fstream.h> 变成了 <fstream>。而对于原来C语言的头文件，也采用同样的方法，但在每个名字前还要添加一个c字母，
所以C语言的 <string.h> 变成了 <cstring>，<stdio.h> 变成了 <cstdio>。

cin、cout、cerr 不是C++中的关键字，其本质是函数调用，它们的实现采用的是C++的运算符重载，这些知识点将会在后续逐一介绍。
其中cout和cerr的输出目的地都是显示器，不同的是cout是带有缓冲的，而cerr则不带缓冲。

如果定义宽字符串，需要加前缀L，例如：
wchar_t *str = L"C语言中文网";
L是必须要加的，并且与字符串之间不能有空格，只有这样编译器才知道每个字符占用两个字节。

和 malloc() 一样，new 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。
为了避免内存泄露，通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现，
并且不要和C语言中 malloc()、free() 一起混用。

注意：是在函数定义时增加 inline 关键字，而不是在函数声明时。在函数声明时增加 inline 关键虽然没有错误，但是也没有任何效果
void swap(int &a, int &b);        //函数声明，左端也可以加inline，不会报错，但无作用
inline void swap(int &a, int &b)  //函数定义，定义swap为内联函数
{
    int temp = a;
    a = b;
    b = temp;
}

函数的重载的规则：
函数名称必须相同。
参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）。
函数的返回类型可以相同也可以不相同。
仅仅返回类型不同不足以成为函数的重载。
函数重载的实现

C++ 代码在编译时会根据参数列表对函数进行重命名，例如，int max(int, int, int) 会被重命名为 _max_int_int_int，
double max(double, double, double) 会被重命名为 _max_double_double_double，所以在本质上来说它们还是不同的函数。
不同的编译器有不同的重命名方式，这里仅仅举例说明。
当发生函数调用时，编译器会根据参数列表去逐个匹配，以选择对应的函数，如果匹配失败，则编译器报错。这叫做重载分辨。

在C++中，定义函数时可以给参数指定一个默认的初始值。调用函数时，可以省略有默认值的参数。
也就是说，如果用户指定了参数的值，那么就使用用户指定的值，否则使用参数的默认值。
C++规定，默认参数只能放在形参列表的最后，而且一旦为某个参数指定了默认值，那么它后面的所有参数都必须有默认值。
实参和形参的传值是从左到右依次匹配的，默认参数的连续性是保证正确传参的前提。
除了函数定义，你也可以在函数声明中指定默认参数。不过默认参数只能指定一次，在声明中指定了就不能在定义中指定，反过来也一样

默认参数和重载

默认参数和重载不能同时出现：使用了默认参数就不能使用重载，使用了重载也不能使用默认参数，它们是相互冲突的。
因为当调用函数时如果少写一个参数，编译器就无法判定是利用函数重载还是利用默认参数，会出现二义性，无法执行。

内存对齐（Memory Alignment）：
1、  对于结构的各个成员，第一个成员位于偏移为0的位置，以后每个数据成员的偏移量必须是min(#pragma pack()指定的数，
这个数据成员的自身长度) 的倍数。
2、  在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，
对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。
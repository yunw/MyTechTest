参考：http://blog.csdn.net/speedme/article/details/48525119

mvcc：
http://blog.sina.com.cn/s/blog_711b11fd0101bhks.html
http://www.cnblogs.com/dongqingswt/p/3460440.html
http://blog.csdn.net/chen77716/article/details/6742128

意向锁的存在价值在于在定位到特定的行所持有的锁之前，提供一种更粗粒度的锁，可以大大节约引擎对于锁的定位和处理的性能，因为在存储引擎内部，锁是由一块独立的数据结构维护的，
锁的数量直接决定了内存的消耗和并发性能。例如，事务A对表t的某些行修改（DML通常会产生X锁），
需要对t加上意向排它锁，在A事务完成之前，B事务来一个全表操作（alter table等），此时直接在表级别的意向排它锁就能告诉B需要等待（因为t上有意向锁），而不需要再去行级别判断。

sql事务标准隔离级别：

如果你希望为一系列语句从 AUTOCOMMIT 模式转换，你可以使用 START TRANSACTION 或 BEGIN 或 BEGIN WORK 语句：

START TRANSACTION;
SELECT @A:=SUM(salary) FROM table1 WHERE type=1;
UPDATE table2 SET summmary=@A WHERE type=1;
COMMIT;

START TRANSACTION 在 MySQL 4.0.11 中被加入；这是被推荐的开始一个特别(ad-hoc)事务的方式，因为这是 ANSI SQL 句法。

注意，如果你使用的是一个非事务安全表，更改会立刻被存储，不受 autocommit 模式状态的约束。 

 脏读 （dirty read）事务T1更新了一行记录的内容，但是并没有提交所做的修改。事务T2读取更新后的行，然后T1执行回滚操作，取消了刚才所做的修改。现在T2所读取的行就无效了。
不可重复读取 （nonrepeatable read）事务T1读取一行记录，紧接着事务T2修改 了T1刚才读取的那一行记录。然后T1又再次读取这行记录，发现与刚才读取的结果不同。这就称为“不可重复”读，因为T1原来读取的那行记录已经发生了变化。
幻像读取 （phantom read）事务T1读取一条指定的WHERE子句所返回的结果集。然后事务T2新插入 一行记录，这行记录恰好可以满足T1所使用的查询条件中的WHERE 子句的条件。然后T1又使用相同的查询再次对表进行检索，但是此时却看到了事务T2刚才插入的新行。这个新行就称为“幻像”，因为对T1来说这一行就像突 然出现的一样。 

Read Uncommitted（读取未提交内容）
       在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
Read Committed（读取提交内容）
       这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。
       这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
Repeatable Read（可重读）
       这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。
       简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。
       InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
Serializable（可串行化）
       这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 
       
mysql  锁机制：
参考： http://blog.sina.com.cn/s/blog_a1e9c7910102vnrj.html
     http://m.blog.csdn.net/article/details?id=51214001
     http://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html
页级锁:引擎 BDB。
表级锁:引擎 MyISAM， 理解为锁住整个表，可以同时读，写不行
行级锁:引擎 INNODB， 单独的一行记录加锁
间隙锁（Gap Lock）:锁定索引记录间隙，确保本事务索引记录的间隙不被其它事务改变。间隙锁是针对事务隔离级别为可重复读或以上级别的。主要目的是防止幻象读。
Next-Key Lock ：行锁和间隙锁组合起来就叫Next-Key Lock。当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。
加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录（否则会改变索引记录的间隙）。默认情况下，InnoDB工作在可重复读隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。
表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许
行级，仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。
页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。 

1、     行锁（Record Lock）
行锁锁定的是索引记录，而不是行数据，也就是说锁定的是key。

2、     间隙锁（Gap Lock）
测试表与数据：
drop table if exists test;
create table test(id int,v1 int,v2 int,primary key(id),key `idx_v1`(`v1`))Engine=InnoDB DEFAULT CHARSET=UTF8;
insert into test (id, v1, v2) values(1,1,0);
insert into test (id, v1, v2) values(2,3,1);
insert into test (id, v1, v2) values(3,4,2);
insert into test (id, v1, v2) values(5,5,3);
insert into test (id, v1, v2) values(7,7,4);
insert into test (id, v1, v2) values(10,9,5);

间隙锁（Gap Lock）一般是针对非唯一索引而言的，test表中的v1（非唯一索引）字段值可以划分的区间为：
（-∞,1）（1,3）（3,4）（4,5）（5,7）（7,9）（9, +∞）
假如要更新v1=7的数据行，那么此时会在索引idx_v1对应的值，也就是v1的值上加间隙锁，锁定的区间是[5,9)。同时找到v1=7的数据行的主键索引和非唯一索引，对key加上锁。

3、后码锁（Next-key lock）：
记录锁和间隙锁的结合，对于InnoDB中，更新非唯一索引对应的记录（在这里来说是更新v1字段的值），会加上Next-Key Lock。如果更新记录为空，就不能加记录锁，只能加间隙锁。
mysql> mysql> select @@global.tx_isolation, @@tx_isolation, @@autocommit, @@innodb_lock_wait_timeout;
+-----------------------+-----------------+--------------+----------------------------+
| @@global.tx_isolation | @@tx_isolation  | @@autocommit | @@innodb_lock_wait_timeout |
+-----------------------+-----------------+--------------+----------------------------+
| REPEATABLE-READ       | REPEATABLE-READ |            1 |                         50 |
+-----------------------+-----------------+--------------+----------------------------+
1 row in set (0.00 sec)

测试（开两个窗口）：
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
操作序号               事务1                                         事务2                                           描述
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1          start transaction;                                                                         开始事务1
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  2          update test set v2=3 where v1=7;                                                           这条sql语句会加next-key lock，v1=7这条记录存在，会用行锁锁定v1=7这个值
                                                                                                                                                                                                                                                                     并锁定v1=7对应的主键索引值。同时锁定v1的值区间[5,9)，这个区间在事务1结束前，其它事务
                                                                                                                                                                                                                                                                     不能在该区间修改记录（因为修改会印象索引的间隙）
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  3                                                    start transaction;                               开始事务2
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  4                                                    insert into test(id, v1,v2) values(18,6,20);     产生锁等待，因为这条sql语句执行后会添加一条v1=6的记录，会改变事务1的间隙锁的索引间隙。
                                                                                                                                                                                                                                                                    事实上，v1=5,6,7，8都会改变事务1的间隙锁的索引间隙，因此更新都不会成功。
                                                                                                                                                                                                                                                                    但v1=9不会，因为事务1的间隙锁不包含9。注意：事务1的间隙锁的区间是左闭右开。
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  5         insert into test(id, v1,v2)values(15,8,8);                                                  这条sql语句会检查next-key lock，由于v1=8不存在，故行锁锁不到，由gap lock锁区间[7,9)
                                                                                                                                                                                                                                                                    这个区间在操作序号2的锁定区间[5,9)内，因此不会修改锁定区间，可以继续执行。
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  6         等待50秒                                                                                                等待50秒                                                                                                      锁等待超时
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  7                                                    ERROR 1205 (HY000): Lock wait timeout exceeded;  操作序号4超时
                                                       try restarting transaction
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  8         commit;                                                                                     提交事务1
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  9                                                   commit;                                           提交事务2
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  11       select * from test;                                                                          查询最终记录：操作序号2、5更新成功。
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4、     锁选择
1）、如果更新条件没有走索引，例如执行“update from test set v2=0 where v2=5;” ，此时会进行全表扫描，扫表的时候，要阻止其他任何的更新操作，所以上升为表锁。
2）、如果更新条件为索引字段，但是并非唯一索引（包括主键索引），例如执行“update from t1 set v2=0 where v1=9;” 那么此时更新会使用Next-Key Lock。使用Next-Key Lock的原因：
a）、首先要保证在符合条件的记录上加上排他锁，会锁定当前非唯一索引和对应的主键索引的值；
b）、还要保证锁定的区间不能插入新的数据。
3）、如果更新条件为唯一索引，则使用Record Lock（记录锁）。
InnoDB根据唯一索引，找到相应记录，将主键索引值和唯一索引值加上记录锁。但不使用Gap Lock（间隙锁）。

5、间隙锁
加后码锁的时候，并没有锁住间隙两端的记录（这里的两端分别是7,9和5,7），那么两端的记录是可以更新的，但是如果更新两端的记录会影响到间隙锁，那么操作会被挂起，等待间隙锁释放
测试（开两个窗口）：
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
操作序号               事务1                                         事务2                                           描述
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1          start transaction;                                                                         开始事务1
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  2          update test set v2=9 where v1=5;                                                           这条sql语句会加next-key lock，v1=5这条记录存在，会用行锁锁定v1=5这个值
                                                                                                                                                                                                                                                                     并锁定v1=5对应的主键索引值。同时由gap lock锁定v1值区间（4,7）
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  3                                                    start transaction;                               开始事务2
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  4                                                    update test set v1=3 where v1=4;                 不会挂起，因为v1=3不在区间（4,7）内
                                                       update test set v1=1 where v1=6;                 不会挂起，因为v1=1不在区间（4,7）内，v1=6在区间内因此
                                                       update test set v1=6 where v1=7;                 操作被挂起，因为v1=6在区间（4,7）内，会影响间隙锁
                                                       update test set v2=10 where v1=3;                不会挂起，v1=3会锁定区间（1,4）
                                                       update test set v2=9 where v1=4;
                                                       update test set v2=6 where v1=6;
                                                       update test set v2=11 where v1=7;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  5         insert into test(id, v1,v2)values(15,8,8);                                                  这条sql语句会检查next-key lock，由于v1=8不存在，故行锁锁不到，由gap lock锁区间（7,9）
                                                                                                                                                                                                                                                                    这个区间在操作序号2的锁定区间（5,9）内，因此不会修改锁定区间，可以继续执行。
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  6         等待50秒                                                                                                等待50秒                                                                                                      锁等待超时
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  7                                                    ERROR 1205 (HY000): Lock wait timeout exceeded;  操作序号4超时
                                                       try restarting transaction
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  8         commit;                                                                                     提交事务1
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  9                                                   commit;                                           提交事务2
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  11       select * from test;                                                                          查询最终记录：操作序号2、5更新成功。
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


插入意向锁（Insert Intention Locks）：
插入意向锁是间隙锁的一种，是在行插入之前由插入操作设置的。此锁表示以如下的方式插入：多个事务插入到相同的索引间隙，如果他们在间隙中的插入位置不同则不需要相互等待。
假设索引记录的值为4和7，两个事务试图插入5和6。





































1、列出本地镜像：
docker images
[root@centos76 bin]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              latest              104bec311bcd        5 days ago          128.9 MB
busybox             latest              e02e811dd08f        10 weeks ago        1.093 MB
hello-world         latest              c54a2cc56cbb        5 months ago        1.848 kB
docker/whalesay     latest              6b362a9f73eb        19 months ago       247 MB
coreos/apache       latest              5a3024d885c8        2 years ago         294.4 MB

2、查看容器：
docker ps -a #查看所有的容器
docker ps    #查看正在运行的容器
[root@centos76 bin]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
8adefedddcac        ubuntu              "/bin/sh -c 'while tr"   4 minutes ago       Up 4 minutes                            nauseous_brown

3、停止容器：
Usage:  docker stop [OPTIONS] CONTAINER [CONTAINER...]
Options:
      --help       Print usage
  -t, --time int   Seconds to wait for stop before killing it (default 10)
[root@centos76 bin]# docker logs 8adefedddcac   #<<<---容器id
hello world
......

[root@centos76 bin]# docker logs nauseous_brown #<<<---容器name
hello world
......

[root@centos76 bin]# docker stop 8adefedddcac
8adefedddcac
[root@centos76 bin]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

[root@centos76 bin]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
53d6868decd3        ubuntu              "/bin/sh -c 'while tr"   4 seconds ago       Up 2 seconds                            adoring_feynman
[root@centos76 bin]# docker stop adoring_feynman
adoring_feynman

docker client：
docker程序称为docker client。你在客户端采取的没有动作都是一个带有一系列标志和参数的命令。
Usage:  [sudo] docker [subcommand] [flags] [arguments] ..
Example: docker run -i -t ubuntu /bin/bash

docker version
docker --help
docker command --help

在docker中运行web application：
docker run -d -P training/webapp python app.py
说明：
-d标志让程序在后台运行，也叫守护进程。
-P标志将容器中需要的任何网络端口映射到宿主机。这让你可以查看web应用。
training/webapp参数是一个预编译的镜像，它包含了一个pathon flask框架的web应用。剩余的参数构成了容器内部运行的命令。python app.py命令启动web应用。

查看web应用容器：
docker ps -l
-l标志只显示最后启动的容器的详情

[root@centos76 bin]# docker ps -l
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES
5d939285f528        training/webapp     "python app.py"     5 minutes ago       Up 5 minutes        0.0.0.0:32768->5000/tcp   cocky_brattain
上面的PORTS列的值：
0.0.0.0:32768->5000/tcp
表明将容器的5000端口映射到宿主机的32768端口上。
网络端口绑定是可配置的：
-P标志是-p 5000的缩写，它将容器的5000端口映射到本地docker主机的一个端口（这个端口的范围是：32768~61000）。
-p 80:5000将容器的5000端口映射到本地docker主机的指定端口80上。

访问web应用：
curl http://localhost:32768
[root@centos76 bin]# curl http://localhost:32768
Hello world!

查看端口映射有专门的命令：
docker port [containerId|containerName] containerPort
[root@centos76 bin]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES
5d939285f528        training/webapp     "python app.py"     18 minutes ago      Up 18 minutes       0.0.0.0:32768->5000/tcp   cocky_brattain
[root@centos76 bin]# docker port cocky_brattain 5000
0.0.0.0:32768

查看web应用的日志：
docker logs -f cocky_brattain
[root@centos76 bin]# docker logs -f cocky_brattain
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
172.17.0.1 - - [21/Dec/2016 01:30:04] "GET / HTTP/1.1" 200 -
-f标志的行为和tail -f的行为类似，可以滚动查看最新的标准输出。

查看web应用容器的进程：
docker top cocky_brattain
[root@centos76 bin]# docker top cocky_brattain
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                9852                9838                0                   09:14               ?                   00:00:00            python app.py
[root@centos76 bin]# docker top cocky_brattain -x
PID                 TTY                 STAT                TIME                COMMAND
9852                ?                   Ss                  0:00                python app.py
可以看到python app.py是容器中唯一的进程。

检查web应用容器：
docker inspect cocky_brattain #返回一个包含指定容器的配置和状态信息的json文档
[root@centos76 bin]# docker inspect cocky_brattain
[
    {
        "Id": "5d939285f52894736239e4a44d69c4667cc8eb82deed4b31edde56ed722a2015",
        "Created": "2016-12-21T01:14:29.978805451Z",
        "Path": "python",
        "Args": [
            "app.py"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 9852,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2016-12-21T01:14:32.642024482Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
......

也可以通过请求特定元素缩小返回的信息，例如返回容器的IP地址，可以：
docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' cocky_brattain
-f标志表示按指定的Go语言的模板输出信息
[root@centos76 bin]# docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' cocky_brattain
172.17.0.2

停止容器：
docker stop cocky_brattain
启动容器：
docker start cocky_brattain
[root@centos76 bin]# docker stop cocky_brattain
cocky_brattain
[root@centos76 bin]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@centos76 bin]# docker start cocky_brattain
cocky_brattain
[root@centos76 bin]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES
5d939285f528        training/webapp     "python app.py"     37 minutes ago      Up 5 seconds        0.0.0.0:32769->5000/tcp   cocky_brattain

删除web应用容器：
docker rm cocky_brattain
[root@centos76 bin]# docker rm cocky_brattain
Error response from daemon: You cannot remove a running container 5d939285f52894736239e4a44d69c4667cc8eb82deed4b31edde56ed722a2015. Stop the container before attempting removal or use -f
[root@centos76 bin]# docker stop cocky_brattain
cocky_brattain
[root@centos76 bin]# docker rm cocky_brattain
cocky_brattain

创建自己的镜像：
docker镜像是容器的基础。每次运行docker run命令，你都告诉它哪个镜像是你想要的。
列出docker主机上的镜像：
docker images
[root@centos76 bin]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              latest              104bec311bcd        5 days ago          128.9 MB
busybox             latest              e02e811dd08f        10 weeks ago        1.093 MB
hello-world         latest              c54a2cc56cbb        5 months ago        1.848 kB
docker/whalesay     latest              6b362a9f73eb        19 months ago       247 MB
training/webapp     latest              6fae60ef3446        19 months ago       348.7 MB
coreos/apache       latest              5a3024d885c8        2 years ago         294.4 MB
docker仓库可能存有一个镜像的多个变体。每个变体都由一个标签来标志，你可以引用一个带标签的镜像，例如：
ubuntu:latest
因此，你可以用带标签的镜像来运行容器，例如：
docker run -t -i ubuntu:14.04 /bin/bash
如果不带标签，那么会使用默认标签：latest
注：最好指定标签，这样就可以明确知道使用的是哪个镜像的变体。这在查问题或调试的时候特别有用。

获取新镜像：
虽然运行容器的时候会自动下载镜像，但这会增加运行容器的时间，如果想预先下载镜像，可以用命令：
docker pull
例如：
docker pull centos
会将centos镜像下载到本地。

搜索镜像：
1、web搜索：https://hub.docker.com/
2、命令搜索：
docker search sinatra
该命令会搜索出所有包含术语sinatra的镜像：
[root@centos76 bin]# docker search sinatra
NAME                                         DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
erikap/ruby-sinatra                          Docker for hosting Sinatra apps                 12                   [OK]
semtech/mu-sinatra-template                  Template for running Ruby/Sinatra microser...   2                    [OK]
zyio/sinatra                                 Tiny-ish Sinatra Dockerfile                     1                    [OK]
samlet/microservices-sinatra-products        microservices with sinatra                      1                    [OK]
lucymhdavies/sinatra-boilerplate             Docker image with my boilerplate for Sinat...   1                    [OK]
thomastanmin/sinatra                         This is the docker example with auto build...   1                    [OK]
tdiary/rpaproxy-sinatra                                                                      1                    [OK]
convox/sinatra                               Convox base image for Sinatra                   0                    [OK]
zhenkyle/sinatra                             Build my own automated build `sinatra` exa...   0                    [OK]
khwada/sinatra                               sinatra for hands on of aws-docker-fluentd-s3   0                    [OK]
mdzhang/docker-sinatra-hello-world           (WIP) Hello World web app using Docker, Si...   0                    [OK]
welldoer/sinatra                             Sinatra webapp                                  0                    [OK]
gwjjeff/sinatra                                                                              0                    [OK]
shaoheshan/sinatra                                                                           0                    [OK]
gk727/sinatra                                this is my sinatra                              0                    [OK]
jaxxstorm/example-sinatra-site               An example sinatra site with versions           0                    [OK]
jeremypruitt/docker-sinatra                  Alpine 3 with ruby, rspec, and sinatra          0                    [OK]
下载你想要的镜像：
docker pull erikap/ruby-sinatra

创建自己的镜像：
方式：
1、从一个镜像运行一个容器，然后修改这个容器，提交容器为一个新的镜像
2、使用dockerfile来指定指令创建镜像。

更新并提交镜像：
[root@centos76 bin]# docker ps -a
CONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS                           PORTS               NAMES
ce565e996fe4        erikap/ruby-sinatra:latest   "/bin/bash"              3 minutes ago       Exited (2) 22 seconds ago                            gigantic_hawking
508147b817e0        ubuntu                       "/bin/bash"              19 minutes ago      Exited (127) 17 minutes ago                          mad_kilby
edc02c57ee68        ubuntu:14.04                 "/bin/bash"              47 minutes ago      Exited (0) 47 minutes ago                            adoring_hawking
81e2abe9c424        ubuntu:14.04                 "/bin/bash"              50 minutes ago      Exited (0) 48 minutes ago                            cocky_saha
53d6868decd3        ubuntu                       "/bin/sh -c 'while tr"   About an hour ago   Exited (137) About an hour ago                       adoring_feynman
8adefedddcac        ubuntu                       "/bin/sh -c 'while tr"   2 hours ago         Exited (137) About an hour ago                       nauseous_brown
7ac3d366d0a7        busybox                      "/bin/sh -c 'while tr"   19 hours ago        Exited (137) 19 hours ago                            busybox1
6801b45b148c        docker/whalesay              "cowsay boo-boo"         20 hours ago        Exited (0) 20 hours ago                              cranky_galileo
d64041bb2120        docker/whalesay              "cowsay boo"             20 hours ago        Exited (0) 20 hours ago                              goofy_agnesi
9220a2cd03aa        hello-world                  "/hello"                 20 hours ago        Exited (0) 20 hours ago                              gigantic_yonath
769fa63d0bde        hello-world                  "/hello"                 21 hours ago        Created                                              berserk_payne
c9c5409ac3bb        hello-world                  "/hello"                 21 hours ago        Created                                              modest_perlman
[root@centos76 bin]# docker commit -m "create test image from a updated container" -a "yinsl" ce565e996fe4 dockeruserabcd/sinatra:v2
sha256:01fbc769ba82d69c091834ce4845bbacbfa931eb7da6ff1afccc222b7465c9f8
从容器ce565e996fe4        erikap/ruby-sinatra:latest创建镜像：dockeruserabcd/sinatra:v2
-m标志允许你指定提交信息。类似git的提交
-a标志允许你指定该更新的作者
[root@centos76 bin]# docker images
REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
dockeruserabcd/sinatra   v2                  01fbc769ba82        16 minutes ago      729 MB
ubuntu                   latest              104bec311bcd        5 days ago          128.9 MB
ubuntu                   14.04               3f755ca42730        5 days ago          187.9 MB
busybox                  latest              e02e811dd08f        10 weeks ago        1.093 MB
hello-world              latest              c54a2cc56cbb        5 months ago        1.848 kB
erikap/ruby-sinatra      latest              b33bf12b86a8        6 months ago        729 MB

2、从dockerfile构建镜像
mkdir mydockerbuild #该目录为构建的上下文环境，意味着该目录包含了构建镜像需要的所有东西。
cd mydockerbuild
vi Dockerfile
FROM docker/whalesay:latest   #表明在镜像docker/whalesay:latest的基础上构建新镜像
RUN apt-get -y update && apt-get install -y fortunes #在镜像中安装程序：fortunes
CMD /usr/games/fortune -a | cowsay #容器运行的时候执行的命令

docker build -t docker-whale .  #创建镜像 -t选项指定了镜像的标签。最后的.表示Dockfile的路径就是当前路径
下面是该命令的构建信息和说明：

Sending build context to Docker daemon 2.048 kB
docker检查和确认它拥有构建镜像所需的一切

Step 1 : FROM docker/whalesay:latest
 ---> 6b362a9f73eb
docker加载镜像：docker/whalesay:latest，因为该镜像在本地存在，因此不用下载。

Step 2 : RUN apt-get -y update && apt-get install -y fortunes
 ---> Running in a9779612a3c6
Ign http://archive.ubuntu.com trusty InRelease
Get:1 http://archive.ubuntu.com trusty-updates InRelease [65.9 kB]
Get:2 http://archive.ubuntu.com trusty-security InRelease [65.9 kB]
Hit http://archive.ubuntu.com trusty Release.gpg
Get:3 http://archive.ubuntu.com trusty-updates/main Sources [473 kB]
Get:4 http://archive.ubuntu.com trusty-updates/restricted Sources [5247 B]
Get:5 http://archive.ubuntu.com trusty-updates/universe Sources [207 kB]
Get:6 http://archive.ubuntu.com trusty-updates/main amd64 Packages [1122 kB]
Get:7 http://archive.ubuntu.com trusty-updates/restricted amd64 Packages [23.5 kB]
Get:8 http://archive.ubuntu.com trusty-updates/universe amd64 Packages [483 kB]
Get:9 http://archive.ubuntu.com trusty-security/main Sources [152 kB]
Get:10 http://archive.ubuntu.com trusty-security/restricted Sources [3944 B]
Get:11 http://archive.ubuntu.com trusty-security/universe Sources [49.4 kB]
Get:12 http://archive.ubuntu.com trusty-security/main amd64 Packages [659 kB]
Get:13 http://archive.ubuntu.com trusty-security/restricted amd64 Packages [20.2 kB]
Get:14 http://archive.ubuntu.com trusty-security/universe amd64 Packages [178 kB]
Hit http://archive.ubuntu.com trusty Release
Hit http://archive.ubuntu.com trusty/main Sources
Hit http://archive.ubuntu.com trusty/restricted Sources
Hit http://archive.ubuntu.com trusty/universe Sources
Hit http://archive.ubuntu.com trusty/main amd64 Packages
Hit http://archive.ubuntu.com trusty/restricted amd64 Packages
Hit http://archive.ubuntu.com trusty/universe amd64 Packages
Fetched 3508 kB in 1min 4s (54.7 kB/s)
Reading package lists...
Reading package lists...
Building dependency tree...
Reading state information...
The following extra packages will be installed:
  fortune-mod fortunes-min librecode0
Suggested packages:
  x11-utils bsdmainutils
The following NEW packages will be installed:
  fortune-mod fortunes fortunes-min librecode0
0 upgraded, 4 newly installed, 0 to remove and 87 not upgraded.
Need to get 1961 kB of archives.
After this operation, 4817 kB of additional disk space will be used.
Get:1 http://archive.ubuntu.com/ubuntu/ trusty/main librecode0 amd64 3.6-21 [771 kB]
Get:2 http://archive.ubuntu.com/ubuntu/ trusty/universe fortune-mod amd64 1:1.99.1-7 [39.5 kB]
Get:3 http://archive.ubuntu.com/ubuntu/ trusty/universe fortunes-min all 1:1.99.1-7 [61.8 kB]
Get:4 http://archive.ubuntu.com/ubuntu/ trusty/universe fortunes all 1:1.99.1-7 [1089 kB]
debconf: unable to initialize frontend: Dialog
debconf: (TERM is not set, so the dialog frontend is not usable.)
debconf: falling back to frontend: Readline
debconf: unable to initialize frontend: Readline
debconf: (This frontend requires a controlling tty.)
debconf: falling back to frontend: Teletype
dpkg-preconfigure: unable to re-open stdin: 
Fetched 1961 kB in 1min 50s (17.8 kB/s)
Selecting previously unselected package librecode0:amd64.
(Reading database ... 13116 files and directories currently installed.)
Preparing to unpack .../librecode0_3.6-21_amd64.deb ...
Unpacking librecode0:amd64 (3.6-21) ...
Selecting previously unselected package fortune-mod.
Preparing to unpack .../fortune-mod_1%3a1.99.1-7_amd64.deb ...
Unpacking fortune-mod (1:1.99.1-7) ...
Selecting previously unselected package fortunes-min.
Preparing to unpack .../fortunes-min_1%3a1.99.1-7_all.deb ...
Unpacking fortunes-min (1:1.99.1-7) ...
Selecting previously unselected package fortunes.
Preparing to unpack .../fortunes_1%3a1.99.1-7_all.deb ...
Unpacking fortunes (1:1.99.1-7) ...
Setting up librecode0:amd64 (3.6-21) ...
Setting up fortune-mod (1:1.99.1-7) ...
Setting up fortunes-min (1:1.99.1-7) ...
Setting up fortunes (1:1.99.1-7) ...
Processing triggers for libc-bin (2.19-0ubuntu6.6) ...
 ---> 8e9f2d3a3f6d
Removing intermediate container a9779612a3c6
更新apt-get包并安装fortunes，期间需要下载更新包和安装包

Step 3 : CMD /usr/games/fortune -a | cowsay
 ---> Running in b264dd0b5dce
 ---> 7c3eda2f21ce
Removing intermediate container b264dd0b5dce
Successfully built 7c3eda2f21ce
最后，docker完成构建并报告结果。

运行：
docker run docker-whale

给image打tag：
docker tag 7c3eda2f21ce dockeruserabcd/docker-whale:latest

登录docker hub：
docker login

上传image到docker hub：
docker push dockeruserabcd/docker-whale

删除本地镜像：
docker rmi docker-whale
或者
docker rmi 7c3eda2f21ce

停止容器：
docker stop container_name

删除容器
docker rm container_name
删除所有容器：
docker rm `docker ps -a -q`

从自己的仓库下载镜像并运行：
docker run dockeruserabcd/docker-whale

hello world 
运行：
docker run ubuntu /bin/echo 'Hello world'
说明： ubuntu 是镜像
    /bin/echo是容器中的命令
    'Hello world'是命令的参数
命令执行完容器就退出运行状态了。

交互式运行容器：
docker run -t -i ubuntu /bin/bash
-t 在新容器中指定一个伪终端
-i 与容器建立一个标准输入（STDIN）的交互式连接
/bin/bash 在容器中打开一个bash shell

以守护进程的方式运行：
docker run -d ubuntu /bin/sh -c "while true; do echo hello world; sleep 1; done"
-d 在后台运行容器（变为守护进程方式）
该命令输出一个长字符串，就是容器id：
efe2a63c44def0703f1adcf435453921f6806e3f2dbc342262e46ecdc64ca22f
使用logs命令查看容器正在做什么：
docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
efe2a63c44de        ubuntu              "/bin/sh -c 'while tr"   3 minutes ago       Up 3 minutes                            goofy_hoover

docker logs goofy_hoover
停止容器：
docker stop goofy_hoover

查看docker版本：
docker version

查看帮助：
docker --help
docker subcmd --help 例如： docker run --help


运行一个简单的web应用：
docker run -d -P training/webapp python app.py
-d 后台运行
-P 映射容器中任意必需的端口到主机。

docker ps -l
-l 显示最后一个创建的容器（不管处于什么状态）
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES
8f4d225549e8        training/webapp     "python app.py"     18 seconds ago      Up 18 seconds       0.0.0.0:32768->5000/tcp   prickly_mcnulty

访问：
curl http://localhost:32768
Hello World!

上面命令的端口是随机的，也可以指定端口映射：
docker run -d -p 80:5000 training/webapp python app.py
-p 80:5000 指定宿主机的80端口映射到容器的5000端口

查看映射端口命令：
docker port prickly_mcnulty 5000
0.0.0.0:32768

查看log：
docker logs -f prickly_mcnulty
-f 可以查看滚动日志，象tail -f一样

查看容器中的进程：
docker top prickly_mcnulty

检查容器：
docker inspect prickly_mcnulty
[root@centos71 ~]# docker inspect prickly_mcnulty
[
    {
        "Id": "8f4d225549e8ba3d985b72767576b71179a70e4dec9c59093000a9f5bb507f42",
        "Created": "2016-09-21T07:13:33.25697515Z",
        "Path": "python",
        "Args": [
            "app.py"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 14838,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2016-09-21T07:13:33.970149111Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:6fae60ef344644649a39240b94d73b8ba9c67f898ede85cf8e947a887b3e6557",
        "ResolvConfPath": "/var/lib/docker/containers/8f4d225549e8ba3d985b72767576b71179a70e4dec9c59093000a9f5bb507f42/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/8f4d225549e8ba3d985b72767576b71179a70e4dec9c59093000a9f5bb507f42/hostname",
        "HostsPath": "/var/lib/docker/containers/8f4d225549e8ba3d985b72767576b71179a70e4dec9c59093000a9f5bb507f42/hosts",
        "LogPath": "/var/lib/docker/containers/8f4d225549e8ba3d985b72767576b71179a70e4dec9c59093000a9f5bb507f42/8f4d225549e8ba3d985b72767576b71179a70e4dec9c59093000a9f5bb507f42-json.log",
        "Name": "/prickly_mcnulty",
        "RestartCount": 0,
        "Driver": "devicemapper",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": true,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": null,
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DiskQuota": 0,
            "KernelMemory": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": -1,
            "OomKillDisable": false,
            "PidsLimit": 0,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0
        },
        "GraphDriver": {
            "Name": "devicemapper",
            "Data": {
                "DeviceId": "59",
                "DeviceName": "docker-253:0-201536278-938952a02a2da718893fbb8d0cd7146c26fb87a593d3ce6549c47b318b50658a",
                "DeviceSize": "10737418240"
            }
        },
        "Mounts": [],
        "Config": {
            "Hostname": "8f4d225549e8",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "5000/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "python",
                "app.py"
            ],
            "Image": "training/webapp",
            "Volumes": null,
            "WorkingDir": "/opt/webapp",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {}
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "f4d681f47b9c6cdefc1b6d83c42a3660da65e2c6d744e29c6d3ed2d1c68640b2",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {
                "5000/tcp": [
                    {
                        "HostIp": "0.0.0.0",
                        "HostPort": "32768"
                    }
                ]
            },
            "SandboxKey": "/var/run/docker/netns/f4d681f47b9c",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "43e2caabb54d0fd094c22754e8a08296cb851654411290c0c81e98cb9d16497b",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "f40c711296b2bcc22d159eb950027de6b8fb1710f830e3f37582e8cb1aa850e9",
                    "EndpointID": "43e2caabb54d0fd094c22754e8a08296cb851654411290c0c81e98cb9d16497b",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02"
                }
            }
        }
    }
]

检查具体元素：
返回容器的ip地址：
docker inspect -f '{{.NetworkSettings.Networks.bridge.IPAddress}}' prickly_mcnulty
返回容器的pid
docker inspect -f '{{.State.Pid}}' prickly_mcnulty

停止容器：
docker stop prickly_mcnulty

启动容器：
docker start prickly_mcnulty

删除容器：
docker stop prickly_mcnulty
docker rm prickly_mcnulty
docker rm $(docker ps -a -q) #删除所有容器

在docker hub上搜索images
docker search centos


创建自己的images：
两种方法：
1、更新一个从镜像创建的容器，然后将结果提交为镜像
2、用Dockerfile指定指令来创建镜像

更新与提交镜像：
更新：
docker run -t -i training/sinatra /bin/bash
在运行的容器中更新ruby
root@8ba495581484:/# apt-get update
root@8ba495581484:/# apt-get upgrade -y ruby
[docker@centos71 ~]$ docker ps -l
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
8ba495581484        training/sinatra    "/bin/bash"         About an hour ago   Exited (1) 6 seconds ago                       stupefied_davinci
提交：
docker commit -m "Added json gem" -a "yin sl" 8ba495581484 dockeruserabcd/sinatra:v2
[docker@centos71 ~]$ docker commit -m "Added json gem" -a "yin sl" 8ba495581484 dockeruserabcd/sinatra:v2
sha256:c570eaaa0907a4863815f89a7cb94d5445e0638fbd81fe2aef5d349caead9f49
[docker@centos71 ~]$ docker images | grep sinatra
dockeruserabcd/sinatra        v2                  c570eaaa0907        23 seconds ago      937.1 MB
training/sinatra              latest              49d952a36c58        2 years ago         447 MB

用Dockerfile创建镜像：
FROM ubuntu:14.04
MAINTAINER yin sl <2225646595@qq.com>
RUN apt-get update && apt-get install -y ruby ruby-dev
RUN gem install sinatra


命名容器：
docker run -d -P --name web training/webapp python app.py
--name 命名一个容器，如果不指定，则自动命名
容器名称有两个功能：
A、容易记忆
B、提供一个引用点，允许其它容器引用。

网络容器（network container）：
docker使用网络驱动来支持网络容器。默认情况下，docker提供两种网路驱动：bridge、overlay。你也可以写自己的网络驱动插件，这样就可以创建自己的驱动程序，这是个高级任务。
每个安装好的docker engine自动包含三个网络，可以列出它们：
docker network ls
[docker@centos71 mydockerbuild]$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
f40c711296b2        bridge              bridge              local               
7d6275425200        host                host                local               
a86b18641d07        none                null                local 

bridge是一个特殊的网络。除非你特别指出，否则，docker就在这个网络上发布你的容器。例如：
docker run -itd --name=networktest ubuntu
docker network inspect bridge
[docker@centos71 mydockerbuild]$ docker run -itd --name=networktest ubuntu
3cbe239a8ecfe06a1332a974561c93689b10c900396791181f149b5ad8dfc07c
[docker@centos71 mydockerbuild]$ docker network inspect bridge
[
    {
        "Name": "bridge",
        "Id": "f40c711296b2bcc22d159eb950027de6b8fb1710f830e3f37582e8cb1aa850e9",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16"
                }
            ]
        },
        "Internal": false,
        "Containers": {
            "3cbe239a8ecfe06a1332a974561c93689b10c900396791181f149b5ad8dfc07c": {
                "Name": "networktest",
                "EndpointID": "0d8ee18b282cf00987efc6225fe84cddb7a3995ee9f2b6a2e27f006c47239522",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {
            "com.docker.network.bridge.default_bridge": "true",
            "com.docker.network.bridge.enable_icc": "true",
            "com.docker.network.bridge.enable_ip_masquerade": "true",
            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
            "com.docker.network.bridge.name": "docker0",
            "com.docker.network.driver.mtu": "1500"
        },
        "Labels": {}
    }
]

你可以从一个网络上删除一个容器，通过断开容器连接的方法。这需要你同时提供网络名称和容器名称（容器id也可以）。
docker network disconnect bridge networktest
[docker@centos71 mydockerbuild]$ docker network disconnect bridge networktest
[docker@centos71 mydockerbuild]$ docker network inspect bridge
[
    {
        "Name": "bridge",
        "Id": "f40c711296b2bcc22d159eb950027de6b8fb1710f830e3f37582e8cb1aa850e9",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16"
                }
            ]
        },
        "Internal": false,
        "Containers": {},
        "Options": {
            "com.docker.network.bridge.default_bridge": "true",
            "com.docker.network.bridge.enable_icc": "true",
            "com.docker.network.bridge.enable_ip_masquerade": "true",
            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
            "com.docker.network.bridge.name": "docker0",
            "com.docker.network.driver.mtu": "1500"
        },
        "Labels": {}
    }
]

网络是隔离其它容器或其它网络的容器的自然的方法。


docker引擎本身支持bridge网络和overlay网络。bridge网络局限于单个主机运行docker引擎。overlay网络可以包含多个主机，是一个更高级的主题。
创建自己的bridge网络：
docker network create -d bridge my-bridge-network
-d bridge 表明新的网络是一个bridge网络
[docker@centos71 mydockerbuild]$ docker network create -d bridge my-bridge-network
260f53ad3e5cfbadb3a9adad40bd753b2eb305a08f1584ee22cca2a839e241fd
[docker@centos71 mydockerbuild]$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
f40c711296b2        bridge              bridge              local               
7d6275425200        host                host                local               
260f53ad3e5c        my-bridge-network   bridge              local               
a86b18641d07        none                null                local 
[docker@centos71 mydockerbuild]$ docker network inspect my-bridge-network
[
    {
        "Name": "my-bridge-network",
        "Id": "260f53ad3e5cfbadb3a9adad40bd753b2eb305a08f1584ee22cca2a839e241fd",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1/16"
                }
            ]
        },
        "Internal": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
可以看到，新网络中什么也没有。

添加容器到新网络：
网络可以提供容器间的完整隔离，在你首次运行容器的时候，可以将容器添加到一个网络。
例如：
docker run -d --network=my-bridge-network --name db training/postgres
[docker@centos71 mydockerbuild]$ docker network inspect my-bridge-network
[
    {
        "Name": "my-bridge-network",
        "Id": "260f53ad3e5cfbadb3a9adad40bd753b2eb305a08f1584ee22cca2a839e241fd",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1/16"
                }
            ]
        },
        "Internal": false,
        "Containers": {
            "0fa26e15b3e70a6a89b4e7168ed5647e6679777c985ccd5491b1d4321073710c": {
                "Name": "db",
                "EndpointID": "56ea7320a56e116c6493d9332ccd27231e753d4a54a4fc03d9b2944855c73edc",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]
[docker@centos71 mydockerbuild]$ docker inspect --format='{{json .NetworkSettings.Networks}}'  db
{"my-bridge-network":{"IPAMConfig":null,"Links":null,"Aliases":["0fa26e15b3e7"],"NetworkID":"260f53ad3e5cfbadb3a9adad40bd753b2eb305a08f1584ee22cca2a839e241fd","EndpointID":"56ea7320a56e116c6493d9332ccd27231e753d4a54a4fc03d9b2944855c73edc","Gateway":"172.18.0.1","IPAddress":"172.18.0.2","IPPrefixLen":16,"IPv6Gateway":"","GlobalIPv6Address":"","GlobalIPv6PrefixLen":0,"MacAddress":"02:42:ac:12:00:02"}}

测试容器隔离性：
docker rm $(docker ps -a -q)
docker run -d --name web training/webapp python app.py
docker run -d --network=my-bridge-network --name db training/postgres

获取web容器的ip地址：
docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' web
或
docker inspect -f '{{.NetworkSettings.Networks.bridge.IPAddress}}' web
[docker@centos71 mydockerbuild]$ docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' web
172.17.0.2
[docker@centos71 mydockerbuild]$ docker inspect -f '{{.NetworkSettings.Networks.bridge.IPAddress}}' web
172.17.0.2

打开正在运行的db容器：
docker exec -it db bash
[docker@centos71 mydockerbuild]$ docker exec -it db bash
root@c20c53032a47:/# ping 172.17.0.2 -c 3                                                                                                                                                                                                                                    
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.

--- 172.17.0.2 ping statistics ---
3 packets transmitted, 0 received, 100% packet loss, time 1999ms
可以看到ping不通。这是因为两个容器运行在不同的网络中。

添加容器到不同的网络中：
docker网络允许你添加容器到任意多的网络中，只要你愿意。你还可以添加正在运行的容器到不同的网络中。
例如：
docker network connect my-bridge-network web
[docker@centos71 mydockerbuild]$ docker network connect my-bridge-network web
[docker@centos71 mydockerbuild]$ docker inspect --format='{{json .NetworkSettings.Networks}}' web
{"bridge":{"IPAMConfig":null,"Links":null,"Aliases":null,"NetworkID":"f40c711296b2bcc22d159eb950027de6b8fb1710f830e3f37582e8cb1aa850e9","EndpointID":"48eabd2f95d926ca0c6e7c8801b2f2b926ceb654d78253e02ee0169984632034","Gateway":"172.17.0.1","IPAddress":"172.17.0.2","IPPrefixLen":16,"IPv6Gateway":"","GlobalIPv6Address":"","GlobalIPv6PrefixLen":0,"MacAddress":"02:42:ac:11:00:02"},
 "my-bridge-network":{"IPAMConfig":{},"Links":null,"Aliases":["2989f1a28259"],"NetworkID":"260f53ad3e5cfbadb3a9adad40bd753b2eb305a08f1584ee22cca2a839e241fd","EndpointID":"c2f893c705555dec7b2981cca4ad48d503cfb05c1435922b2e15ed738d96b4cb","Gateway":"172.18.0.1","IPAddress":"172.18.0.3","IPPrefixLen":16,"IPv6Gateway":"","GlobalIPv6Address":"","GlobalIPv6PrefixLen":0,"MacAddress":"02:42:ac:12:00:03"}}
可以看到，web容器已经有两个ip地址了
[docker@centos71 mydockerbuild]$ docker exec -it db bash
root@c20c53032a47:/# ping web -c 3                                                                                                                                                                                                                                           
PING web (172.18.0.3) 56(84) bytes of data.
64 bytes from web.my-bridge-network (172.18.0.3): icmp_seq=1 ttl=64 time=0.201 ms
64 bytes from web.my-bridge-network (172.18.0.3): icmp_seq=2 ttl=64 time=0.119 ms
64 bytes from web.my-bridge-network (172.18.0.3): icmp_seq=3 ttl=64 time=0.117 ms

--- web ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2001ms
rtt min/avg/max/mdev = 0.117/0.145/0.201/0.041 ms
再次运行ping命令（这次使用容器名称：web），ping成功了，显示了一个不同以前（172.17.0.2）的新ip（172.18.0.3）。旧的ip在bridge网络上，新的ip在my-bridge-network网络上。


container links:
docker run -d -P training/webapp python app.py
-P 自动映射容器中的网络端口到docker主机的临时端口范围（ephemeral port range）中的随机一个。
docker run -d -p 80:5000 training/webapp python app.py
-p 指定端口映射
docker run -d -p 8000-9000:5000 training/webapp python app.py
-p 指定临时端口范围，这样主机的临时端口会是8000-9000中的随机一个
docker run -d -p 127.0.0.1:80:5000 training/webapp python app.py
-p 指定网络接口和端口映射，默认绑定到dockers主机的所有网络接口。
docker run -d -p 127.0.0.1::5000 training/webapp python app.py
-p指定网络接口，端口动态
docker run -d -p 127.0.0.1:80:5000/udp training/webapp python app.py
-p 指定udp端口，通过添加/udp

Communication across links：
docker stop `docker ps -a -q`
docker rm `docker ps -a -q`
docker run -d --name db training/postgres
创建一个新的web容器并与db容器链接。
docker run -d -P --name web --link db:db training/webapp python app.py
--link <name or id>:alias 名称就是我们要链接的容器，也可以不要别名：--link<name or id> 如果不要别名，那么别名就是容器名。
[docker@centos71 mydockerbuild]$ docker inspect -f "{{ .HostConfig.Links }}" web
[/db:/web/db]
可以看到，web容器现在链接到db容器web/db上了，这样它就可以访问db容器上的信息了。

link做了什么？
link允许源容器提供它自己的信息给收件人容器（recipient container）。上述例子中，收件人web能访问源db。为了做到这一点，docker在两个容器之间创建了一个安全隧道，不需要
暴露任何容器上的端口给外部。我们在启动db容器的时候没有使用-p和-P选项。这是link的一个很大的好处：我们不需要暴露源容器，这个例子里就是PostgreSQL database，到网络上。
docker暴露源容器的链接信息给收件人容器，通过以下两种方式：
环境变量
更新/etc/hosts文件

环境变量：
在链接容器的时候docker创建了几个环境变量。docker基于--link参数在目标容器中创建环境变量。它也暴露所有的源自docker源自源容器的环境变量。这些变量来自于：
A、源容器Dockerfile中ENV命令定义的变量
B、源容器启动时，执行docker run命令时添加的 -e --env --env-file等选项制定的变量
这些环境变量能让目标容器发现与源容器相关的信息。
注意：一个容器中源自docker的环境变量对所有链接到它的容器都是可见的，如果敏感信息存储在这些变量中，可能带来严重的安全隐患。
docker设置一个<alias>_NAME环境变量，为每一个用--link参数列举的目标容器。例如，一个新的叫web的容器链接到一个叫db的容器上，通过 --link db:webdb，那么docker就
会在web容器中创建一个WEBDB_NAME=/web/webdb变量。
docker也为源容器暴露出来的端口定义一套环境变量。每个变量都有唯一的前缀，采用下面的格式：
<name>_PORT_<port>_<protocol>
name： --link参数中的别名，如webdb
port：暴露的端口号
protocol：TCP或UDP
docker使用这个前缀定义三个不同的环境变量：
prefix_ADDR：包含了ip地址，例如：WEBDB_PORT_5432_TCP_ADDR=172.17.0.82
prefix_PORT：包含了端口，例如：WEBDB_PORT_5432_TCP_PORT=5432
prefix_PROTO：包含了协议，例如：WEBDB_PORT_5432_TCP_PROTO=tcp
如果容器暴露了多个端口，那么就会为每个端口设置一套环境变量。例如，容器暴露了4个端口，那么docker就会创建12个环境变量，每个端口3个。
另外，docker还创建了一个叫<alias>_PORT的环境变量。这个变量包含了源容器url中的首个暴露的端口。首个端口的定义是暴露的端口中数字最小的一个。例如：
WEBDB_PORT=tcp://172.17.0.82:5432，如果这个端口既用于tcp也用于udp，那么它就代表tcp
回到我们的例子中来，我们可以运行env命令来列出指定容器的环境变量：
docker run --rm --name web2 --link db:db training/webapp env
--rm 自动删除容器如果它已经存在
[docker@centos71 mydockerbuild]$ docker run --rm --name web2 --link db:db training/webapp env
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=b80dd9cf51fa
DB_PORT=tcp://172.17.0.2:5432
DB_PORT_5432_TCP=tcp://172.17.0.2:5432
DB_PORT_5432_TCP_ADDR=172.17.0.2
DB_PORT_5432_TCP_PORT=5432
DB_PORT_5432_TCP_PROTO=tcp
DB_NAME=/web2/db
DB_ENV_PG_VERSION=9.3
HOME=/root
可以看到docker创建了一套有关源容器db的环境变量。你可以用这些环境变量配置你自己的应用来连接db容器中的数据库，这个连接将是安全和私有的：只有链接到db容器的web容器可以和它通信。
注意：存储在环境变量中的ip地址不会自动更新，如果源容器重启。这一点和更新/etc/hosts文件不一样，因此，建议使用/etc/hosts方式解析ip地址。

更新/etc/hosts文件：
除了环境变量，docker还在/etc/hosts中添加了一个源容器的条目。例如：
[docker@centos71 mydockerbuild]$ docker run -t -i --rm --link db:webdb training/webapp /bin/bash
root@cdb8f03c0307:/opt/webapp# cat /etc/hosts
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.17.0.2      webdb 7c013eea3faf db
172.17.0.4      cdb8f03c0307
可以看见两个相关的条目：
172.17.0.4      cdb8f03c0307
这个是针对web容器的，使用容器id做hostname。
172.17.0.2      webdb 7c013eea3faf db
这个采用容器别名来引用db容器的ip地址，除了你提供的别名——如果--link提供的别名是唯一的——那么被链接的容器的hostname也会被添加。
如果重启源容器，链接的容器的/etc/hosts将被自动更新为源容器的新ip。


管理容器中的数据：
docker引擎管理数据的两种方式：
数据卷（data volumes）
数据卷容器（data volume containers）

数据卷：
数据卷是在一个或多个容器中特别设计的目录，它绕过了联合文件系统。数据卷为持久化或共享数据提供了几个有用的特性：
1）容器创建的时候卷就被初始化了。如果容器的基础镜像在特定的挂载点包含有数据，这些存在的数据就会在卷初始化的时候拷贝到新的卷中。
2）数据卷可以在容器之间共享和重用。
3）对数据卷的修改直接生效
4）镜像升级时对数据卷的修改不会被包含进去
5）数据卷持久存在，即使容器本身已经被删除
数据卷被设计来持久化数据，独立于容器的生命周期。docker因此永远也不会自动删除卷，当你删除容器的时候。在没有容器引用卷的时候卷也不会被“垃圾收集”。

添加一个卷：
docker run -d -P --name web -v /webapp training/webapp python app.py
这将会在容器中创建一个卷：/webapp
你可以通过docker inspect命令找到卷在主机上的位置：
docker inspect web
[docker@centos71 mydockerbuild]$ docker run -d -P --name web -v /webapp training/webapp python app.py
5e1a285e6f6ae626307f456c5dfbbd67d846a13733dfe541639a082236ccc166
[docker@centos71 mydockerbuild]$ docker inspect --format='{{json .Mounts}}' web
[{"Name":"1282ccf7a0c44f58377423392150486e7e0f57943a76233ad2f8e337e0846c04",
  "Source":"/var/lib/docker/volumes/1282ccf7a0c44f58377423392150486e7e0f57943a76233ad2f8e337e0846c04/_data",
  "Destination":"/webapp",
  "Driver":"local",
  "Mode":"",
  "RW":true,
  "Propagation":""
}]
其中Source指出了卷在主机上的位置，Destination指出了卷在容器中的位置。RW指定了卷的读/写模式。

挂载一个主机目录作为一个数据卷：
除了用-v选项创建一个卷，你也可以挂载docker引擎所在的主机的一个目录到容器中。例如：
docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py
这个命令挂载主机目录：/src/webapp到容器的/opt/webapp。如果/opt/webapp在容器的镜像中已经存在，/src/webapp挂载将覆盖但不删除已经存在的内容。一旦挂载被删除，这些
内容就可以再次被访问。这与mount命令的行为是一致的。
容器目录必须是绝对路径，如/opt/webapp。主机目录可以是一个绝对路径也可以是一个名称值。如果你为主机目录提供了一个绝对路径，docker将绑定挂载到你指定的目录上。如果你提供了一个名字。
docker将用这个名称创建一个命名卷。例如：你可以为主机目录提供/foo 或 foo。如果是/foo，docker引擎将绑定挂载。如果提供foo，docker引擎将创建一个命名卷（默认主机地址在/var/lib/docker/volumes下创建）。
docker卷默认挂载为读写模式，但是也可以设置为只读模式：
docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py

挂载一个共享存储卷作为一个数据卷：
除了在容器中挂载主机目录，某些docker卷插件允许你规定并挂载共享存储，例如： iSCSI, NFS, or FC。
使用共享卷的好处是他们是主机独立的。这意味着，卷对所有主机可见，只要安装了插件，容器在启动后就可以在后端访问共享存储。
docker run -d -P \
  --volume-driver=flocker \
  -v my-named-volume:/opt/webapp \
  --name web training/webapp python app.py
这个命令创建了一个命名卷：my-named-volume，使用flocker卷驱动，让它在容器的/opt/webapp下可见。
也可以用docker volume create命令创建卷，在容器使用之前。
$ docker volume create -d flocker -o size=20GB my-named-volume
$ docker run -d -P \
  -v my-named-volume:/opt/webapp \
  --name web training/webapp python app.py

卷标（volume label）：

挂载一个主机文件作为数据卷：
-v选项也可以挂载单个文件
docker run --rm -it -v ~/.bash_history:/root/.bash_history ubuntu /bin/bash
这个命令可以进入一个新容器的bash shell，当你从容器中退出的时候，主机可以获得你在容器中执行的命令的历史信息。

创建并挂载一个数据卷容器：
如果你有些持久化数据你想在容器之间共享，或者非持久化的容器想使用。最好的方式是创建一个命名的数据卷容器。然后从它里面挂载数据。
docker create -v /dbdata --name dbstore training/postgres /bin/true
该命令创建了一个共享数据卷容器
docker run -d --volumes-from dbstore --name db1 training/postgres
该命令挂载了共享数据卷容器的共享卷
另一个：
docker run -d --volumes-from dbstore --name db2 training/postgres
上面的例子里，如果postgres镜像包含了一个叫/dbdata的目录，那么从dbstore容器挂载的卷将隐藏它，只有来自dbstore容器的/dbdata是可见的。
这种挂载还可以继承：
docker run -d --name db3 --volumes-from db1 training/postgres
如果你删除了挂载卷的容器，包括最初的dbstore容器，卷也不会被删除。要从磁盘上删除卷，你必须显式执行docker rm -v，在最后一个引用该卷的容器上。这允许你升级或在容器间迁移数据。
注：
在你删除容器的时候，你没有提供-v选项去删除它的卷，docker不会给出警告。如果你删除容器而没有使用-v选项，你就留下了一个"dangling"卷，这样的卷不再被容器引用。
你可以用docker volume ls -f dangling=true来发现dangling卷。然后使用docker volume rm <volume name>来删除不需要的卷。

备份、再存储、迁移数据卷：
卷的另一个有用的功能是备份、再存储、迁移数据。可以通过--volumes-from创建一个新的容器挂载这个卷。例如：
docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
这个命令创建了一个新的容器并从dbstore容器挂载了卷。然后你又挂载了一个本地主机目录到/backup。最终，你通过tar命令备份了dbdata卷到backup.tar存储在/backup目录下。
当命令执行完毕容器停止后我们就保留了dbdata卷的一个备份。
然后你就可以创建一个新的容器将它再存储其他任何地方了：
docker run -v /dbdata --name dbstore2 ubuntu /bin/bash
然后解压备份文件到新容器的卷里：
docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c "cd /dbdata && tar xvf /backup/backup.tar --strip 1"

删除卷：
你可以创建命名卷和匿名卷。命名卷在容器外有一个特定的源表（source form），例如：awesome:/bar。匿名卷没有特定的源。当容器删除的时候，你应该指导docker引擎清除匿名卷。
为了做到这一点，需要使用 --rm选项，例如：
docker run --rm -v /foo -v awesome:/bar busybox top
这个命令创建了一个匿名的卷：/foo。当容器删除的时候，docker引擎删除/foo卷，但不删除命名卷：awesome。





















docker hub account：dockuserabcd/qqmail/abcd_1234

镜像导入导出：
导出：
docker save gcr.io/google_containers/kubernetes-dashboard-amd64:v1.0.1 > dashboard.tar
导入：
docker load < dashboard.tar 
查看导入镜像：
[root@centos72 ~]# docker images | grep dashboard
gcr.io/google_containers/kubernetes-dashboard-amd64   v1.0.1              f33198caac8e        12 weeks ago        44.09 MB

概念：
Dock Image（dock镜像）：
就是一个只读模板。镜像可以用来创建容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。

Docker Container（docker容器）：docker利用容器来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是隔离的保证安全的平台。
              可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。
*注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。

Docker Repository（docker仓库）：仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，
仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。
仓库分为公开仓库（Public）和私有仓库（Private）两种形式。
最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括 Docker Pool等，可以提供大陆用户更稳定快速的访问。
当然，用户也可以在本地网络内创建一个私有仓库。
当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。
*注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。

Docker 运行容器前需要本地存在对应的镜像，如果镜像不存在本地，Docker 会从镜像仓库下载（默认是Docker Hub 公共注册服务器中的仓库）。

获取镜像：docker pull

docker pull ubuntu:12.04 #该命令相当于：docker pull registry.hub.docker.com/ubuntu:12.04 
即从注册服务器 registry.hub.docker.com 中的 ubuntu 仓库来下载标记为 12.04 的镜像。
有时候官方仓库注册服务器下载较慢，可以从其他仓库下载。 从其它仓库下载时需要指定完整的仓库注册服务器地址。例如：
docker pull dl.dockerpool.com:5000/ubuntu:12.04
完成后，即可随时使用该镜像了，例如创建一个容器，让其中运行 bash 应用。
docker run -t -i ubuntu:12.04 /bin/bash

列出本地镜像：docker images
[root@k8s-master ~]# docker images
REPOSITORY                                            TAG                                  IMAGE ID            CREATED             VIRTUAL SIZE
tracereport                                           3.0.0-SNAPSHOT-1462865916            2826ee55057e        23 hours ago        103.6 MB
tracereport                                           3.0.0-SNAPSHOT-1462867386            2826ee55057e        23 hours ago        103.6 MB
tracereport                                           3.0.0-SNAPSHOT-1462867653            2826ee55057e        23 hours ago        103.6 MB
tracereport                                           3.0.0-SNAPSHOT-1462870345            2826ee55057e        23 hours ago        103.6 MB
tracereport                                           3.0.0-SNAPSHOT-1462870447            2826ee55057e        23 hours ago        103.6 MB
sample-app                                            0.0.1-SNAPSHOT-1462853704            772136f4ebcd        25 hours ago        56.14 MB

在列出信息中，可以看到几个字段信息
来自于哪个仓库，比如：tracereport
镜像的标记，比如：3.0.0-SNAPSHOT-1462865916
它的 ID 号（唯一），比如：2826ee55057e
创建时间，比如：23 hours ago
镜像大小，比如：103.6 MB

其中镜像的 ID 唯一标识了镜像，注意到 3.0.0-SNAPSHOT-1462865916 和 3.0.0-SNAPSHOT-1462870447 具有相同的镜像 ID ，说明它们实际上是同一镜像。
TAG 信息用来标记来自同一个仓库的不同镜像。例如 tracereport仓库中有多个镜像，通过 TAG 信息来区分发行版

利用 Dockerfile 来创建镜像：
首先需要创建一个 Dockerfile，包含一些如何创建镜像的指令。
新建一个目录和一个 Dockerfile
mkdir imgtest
cd imgtest
touch Dockerfile
Dockerfile的内容如下（一个包含java和tomcat的镜像）：
FROM centos
MAINTAINER yinsl "2225646595@qq.com"
WORKDIR /root/dockerroot
RUN yum install -y java-1.8.0-openjdk wget
RUN wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.0.33/bin/apache-tomcat-8.0.33.tar.gz
RUN tar xvf apache-tomcat-8.0.33.tar.gz && mv ./apache-tomcat-8.0.33 /usr/local
RUN touch startup.sh
RUN echo "/usr/local/apache-tomcat-8.0.33/bin/startup.sh">> startup.sh
COPY startup.sh /root/startup.sh
RUN chmod a+x /root/startup.sh
EXPOSE 8080
ENTRYPOINT /root/startup.sh



创建的命令为：
docker build [OPTIONS] path #path为包含Dockerfile的路径（包含子路径）
该命令将读取指定路径下（包括子目录）的 Dockerfile，并将
该路径下所有内容发送给 Docker 服务端，由服务端来创建镜像。因此一般建议放置 Dockerfile 的目录为空目录。
也可以通过 .dockerignore 文件（每一行添加一条匹配模式）来让 Docker 忽略路径下的目录和文件。
要指定镜像的标签信息，可以通过 -t 选项，例如：
docker build -t myrepo/myapp /tmp/test1/

Dockfile简介：
基本结构：
Dockerfile 由一行行命令语句组成，并且支持以 # 开头的注释行。
一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。
指令：
指令的一般格式为INSTRUCTION arguments，指令包括FROM、MAINTAINER、RUN等。
FROM
格式为 FROM <image> 或 FROM <image>:<tag> 。
第一条指令必须为 FROM 指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）。
MAINTAINER
格式为MAINTAINER <name>，指定维护者信息。
RUN
格式为 RUN <command> 或 RUN ["executable", "param1", "param2"] 。
前者将在 shell 终端中运行命令，即 /bin/sh -c ；后者则使用 exec 执行。指定使用其它终端可以通过
第二种方式实现，例如 RUN ["/bin/bash", "-c", "echo hello"] 。
每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用\来换行。
CMD
支持三种格式
    CMD ["executable","param1","param2"] 使用 exec 执行，推荐方式；
    CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；
    CMD ["param1","param2"] 提供给 ENTRYPOINT 的默认参数；
指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。
如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。
EXPOSE
格式为 EXPOSE <port> [<port>...] 。
告诉Docker服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker主机会自动分配一个端口转发到指定的端口。
ENV
格式为 ENV <key> <value> 
 指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。
ADD
格式为 ADD <src> <dest>
该命令将复制指定的 <src> 到容器中的 <dest> 。 其中 <src> 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。
COPY
格式为 COPY <src> <dest>
复制本地主机的 <src> （为 Dockerfile 所在目录的相对路径）到容器中的 <dest> 。当使用本地目录为源目录时，推荐使用 COPY 。
ENTRYPOINT
两种格式：
ENTRYPOINT ["executable", "param1", "param2"]
ENTRYPOINT command param1 param2 （shell中执行）
配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。每个 Dockerfile 中只能有一个 ENTRYPOINT ，当指定多个时，只有最后一个起效
VOLUME
格式为 VOLUME ["/data"]
创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。
USER
格式为 USER daemon
指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。
当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如： RUN groupadd -r postgres && useradd -r -g postgres postgres 。
要临时获取管理员权限可以使用 gosu ，而不推荐 sudo 。
WORKDIR
格式为 WORKDIR /path/to/workdir
为后续的 RUN 、 CMD 、 ENTRYPOINT 指令配置工作目录。
可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如：
WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
则最终路径为 /a/b/c 。
ONBUILD
格式为 ONBUILD [INSTRUCTION]
配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。
例如，Dockerfile 使用如下的内容创建了镜像 image-A 。
[...]
ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src
[...]
如果基于 image-A 创建新的镜像时，新的Dockerfile中使用 FROM image-A 指定基础镜像时，会自动执行ONBUILD 指令内容，等价于在后面添加了两条指令。
FROM image-A
#Automatically run the following
ADD . /app/src
RUN /usr/local/bin/python-build --dir /app/src

关于docker run命令
-v，--volume=[]绑定一个挂载点
格式：([host-dir:]container-dir[:<suffix options>], where suffix options are comma delimited and selected from [rw|ro] and [z|Z].)
例如：-v /host-dir:/container-dir，将宿主机的/host-dir绑定到docker容器的/container-dir上。
-v选项可以使用多次以绑定多个挂载点。这些挂在点可以被其他容器使用（通过使用--volume-from选项）。
volume可选后缀:ro 和:rw用来表明挂载点是只读还是读写模式。默认情况下为读写模式。
volume可选后缀:z和:Z用来表明volume是公有还是私有volume。z表明是公有（所有容器都可以读写该volume），Z表明是私有（只有当前容器可以使用该volume）。
container-dir必须是绝对路径，例如：/src/docs。

centos7安装docker：
yum install -y docker
service docker start
chkconfig docker on


搜索镜像：
[root@localhost ~]# docker search centos
INDEX       NAME                                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
docker.io   docker.io/centos                          The official build of CentOS.                   2253      [OK]       
docker.io   docker.io/jdeathe/centos-ssh              CentOS-6 6.7 x86_64 / CentOS-7 7.2.1511 x8...   23                   [OK]
docker.io   docker.io/jdeathe/centos-ssh-apache-php   CentOS-6 6.7 x86_64 / Apache / PHP / PHP M...   17                   [OK]
......





1、centos7下安装 etcd 和kubuernetes（会自动安装docker）：
yum install -y etcd kubernetes
2、修改docker的配置文件：
vi /etc/sysconfig/docker
将OPTIOINS的内容设置为：
OPTIONS='--selinux-enabled=false --insecure-registry gcr.io'
3、修改kubernetes apiserver的配置文件：
vi /etc/kubernetes/apiserver
把--admissin_control参数中的ServiceAccount删除
4、按顺序启动所有服务：
systemctl start etcd
systemctl start docker
systemctl start kube-apiserver
systemctl start kube-controller-manager
systemctl start kube-scheduler
systemctl start kubelet
systemctl start kube-proxy
至此，一个单机版的kubernetes集群环境就安装启动完成了。

下载docker镜像（存储在本地/var/lib/docker目录下）：
docker pull kubeguide/guestbook-php-frontend


docker的启动配置文件：/usr/lib/systemd/system/docker.service
其他配置文件：/etc/sysconfig/docker
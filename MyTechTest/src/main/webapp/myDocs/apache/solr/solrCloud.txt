关键概念：
逻辑概念：
一个集群可以持有多个solr文档的集合。
一个集合可以被分为多个碎片，它包含一个集合的文档的子集。
一个集合的碎片数量决定了：
        一个集合能够容纳文档数量的理论限制。
        一个独立查询请求的并发数量。
        
物理概念：
一个集群由一个或多个solr节点组成，它们是运行solr服务进程的实例。
每个节点可以持有多个core。
集群中的每个core是逻辑碎片一个副本。
对指定的集合来说每个副本都使用相同的配置。
每个碎片的副本数量决定了：
        集合内置的冗余水平，以及当某些节点不可用时集群如何容错。
        高负载下处理并发查询请求的数量的理论极限。
        
Shards and Indexing Data in SolrCloud
当你的集合在一个节点中变得太大了，你可以创建碎片来存储在多个部件中。
一个碎片（shard）是一个集合的逻辑分区（logical patition），包含了这个集合的部分文档，集合中的每个文档仅仅被包含在一个碎片中。
例如，你可能有一个集合，它每个文档都有一个“国家”字段，由它决定它属于哪个碎片，因此拥有相同的国家的文档被存储在同一个碎片中。不同的集合也可以
简单的对每个文档的uniqueKey进行散列来确定它属于哪个碎片。

solrcloud在索引和查询的时候都自动支持分布式，并且由zookeeper支持容错和负载均衡。另外，每个碎片都可以有多个副本，提供了额外的鲁棒性。
在solrclound中没有master和slave。相反，每个碎片都至少包含一个物理副本，其中的一个是leader。leader是自动选举出来的，在先来先服务（first-come-first-served）的基础上然后由zookeeper进行选举。
如果一个leader宕机了，剩下的副本中的某个会被选举为新的leader。
当一个文档被发送到solr节点进行索引的时候，系统首选确定该文档属于哪个碎片，然后看哪个节点是该碎片的leader。该文档于是被发送到这个leader进行索引，然后leader将更新发送到所有的副本。

Document Routing
在你创建你的集合的时候solr有能力通过参数：router.name来指定路由的实现。如果你使用“compositeId”（复合id）路由（默认）。
你可以发送文档，文档id带有前缀，它将被用来计算hash以确定文档将被送到哪个碎片进行索引。前缀可以是你想要的任何东西，但它必须是一致的，因此solr的行为才会一致。例如你想把用客户来归档。
你可以用客户的名称或ID来做前缀，如果你的客户是“IBM”，例如，一个文档的id是12345。你可以插入前缀到你的文档id字段："IBM!12345"。感叹号（!）是至关重要的。它用于分辨前缀。
在查询阶段，可以包含前缀到你的查询中，用_route_参数（例如：q=solr&_route_=IBM!）直接查询指定的碎片。在某些情况下，它提升了查询性能，因为它客服了网络延迟，不用查询所有的碎片。 

compositeId路由支持两级路由。例如：第一个前缀用用地域路由，第二个用用户路由："USA!IBM!12345"

如果你不想干涉文档的存储方式，可以不在文档id前指定前缀。

如果在你创建集合的时候指定了一个“隐式”的路由，那么你还可以额外定义一个router.field参数来指定每个文档属于哪个碎片。如果文档中的这个字段找不到，文档将被拒绝。


Shard Splitting
当你在solrcloud中创建集合（collection）的时候，你需要确定碎片（shard）的初始数量。但是很难提前知道你需要的碎片数量。如果后期需要改变，成本会很高，需要重新生成core，重新索引。
拆分碎片的能力在集合API中，目前，允许分成两个新的碎片。老的碎片可以删除。






















